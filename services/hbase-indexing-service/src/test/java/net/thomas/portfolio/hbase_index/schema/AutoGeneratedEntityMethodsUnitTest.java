package net.thomas.portfolio.hbase_index.schema;

import static net.thomas.portfolio.common.utils.ToStringUtil.asString;
import static net.thomas.portfolio.hbase_index.schema.EntitySamplesForTesting.getComponentType;
import static net.thomas.portfolio.hbase_index.schema.EntitySamplesForTesting.getFieldsExceptUid;
import static net.thomas.portfolio.hbase_index.schema.EntitySamplesForTesting.getFirstConstructor;
import static net.thomas.portfolio.hbase_index.schema.EntitySamplesForTesting.isArray;
import static net.thomas.portfolio.hbase_index.schema.EntitySamplesForTesting.runTestOnAllEntityTypes;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertTrue;

import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;

import org.junit.Test;

public class AutoGeneratedEntityMethodsUnitTest {
	private static final String SOME_STRING = "Some string";

	@Test
	public void shouldCalculateHashCode() {
		runTestOnAllEntityTypes((entity) -> {
			assertNotEquals("Calculation of hashcode for entity returned zero for " + entity, 0, entity.hashCode());
		});
	}

	@Test
	public void shouldCalculateHashCodeWithNullField() {
		runTestOnAllEntityTypes((entity) -> {
			for (final Field field : getFieldsExceptUid(entity)) {
				if (!"uid".equals(field.getName())) {
					assertInstanceWithFieldAsNullCanCalculateHashCode(entity, field);
				}
			}
		});
	}

	@Test
	public void shouldBeEqualToItself() {
		runTestOnAllEntityTypes((entity) -> {
			assertTrue("Comparisson of entity to itself had unexpected outcome for " + entity, entity.equals(entity));
		});
	}

	@Test
	public void shouldNotBeEqualToNull() {
		runTestOnAllEntityTypes((entity) -> {
			assertFalse("Comparisson of entity to null had unexpected outcome for " + entity, entity.equals(null));
		});
	}

	@Test
	@SuppressWarnings("unlikely-arg-type")
	public void shouldNotBeEqualToDifferentObject() {
		runTestOnAllEntityTypes((entity) -> {
			assertFalse("Comparisson of entity to different object type had unexpected outcome for " + entity, entity.equals(SOME_STRING));
		});
	}

	@Test
	public void shouldNotEqualToCopyOfItselfWithNullField() {
		runTestOnAllEntityTypes((entity) -> {
			for (final Field field : getFieldsExceptUid(entity)) {
				if (!"uid".equals(field.getName())) {
					assertNewInstanceWithFieldAsNullIsNotEqualToOriginal(entity, field);
				}
			}
		});
	}

	private void assertInstanceWithFieldAsNullCanCalculateHashCode(Entity entity, Field field)
			throws InstantiationException, IllegalAccessException, InvocationTargetException {
		final Entity newInstance = createNewInstanceWithFieldSetToNull(entity, field);
		assertNotEquals("Calculation of hashcode for entity returned zero for " + entity, 0, newInstance.hashCode());
	}

	private void assertNewInstanceWithFieldAsNullIsNotEqualToOriginal(Entity entity, Field field)
			throws InstantiationException, IllegalAccessException, InvocationTargetException {
		final Object[] arguments = buildArgumentListWithSpecifiedFieldAsNull(entity, field);
		final Constructor<?> constructor = getFirstConstructor(entity);
		final Entity newInstance1 = (Entity) constructor.newInstance(arguments);
		final Entity newInstance2 = (Entity) constructor.newInstance(arguments);
		assertFalse("Comparisson of entity to different object type had unexpected outcome for " + entity, entity.equals(newInstance1));
		assertFalse("Comparisson of entity to different object type had unexpected outcome for " + entity, newInstance1.equals(entity));
		assertTrue("Comparisson of entity to different object type had unexpected outcome for " + entity, newInstance1.equals(newInstance2));
	}

	private Object[] buildArgumentListWithSpecifiedFieldAsNull(Entity entity, Field field) throws IllegalAccessException {
		final Object[] arguments = new Object[getFieldsExceptUid(entity).length];
		int argument = 0;
		for (final Field entityField : getFieldsExceptUid(entity)) {
			if (entityField.equals(field)) {
				if (isArray(field)) {
					arguments[argument++] = Array.newInstance(getComponentType(field), 0);
				} else {
					arguments[argument++] = null;
				}
			} else {
				arguments[argument++] = entityField.get(entity);
			}
		}
		return arguments;
	}

	@Test
	public void shouldContainAllFieldsInStringRepresentation() {
		runTestOnAllEntityTypes((entity) -> {
			final String entityAsString = entity.toString();
			for (final Field field : getFieldsExceptUid(entity)) {
				assertValueForFieldIsPresentInString(entity, field, entityAsString);
			}
		});
	}

	private Entity createNewInstanceWithFieldSetToNull(Entity entity, Field field)
			throws IllegalAccessException, InstantiationException, InvocationTargetException {
		final Object[] arguments = buildArgumentListWithSpecifiedFieldAsNull(entity, field);
		final Constructor<?> constructor = getFirstConstructor(entity);
		return (Entity) constructor.newInstance(arguments);
	}

	private void assertValueForFieldIsPresentInString(Object entity, final Field field, final String unitAsString) throws IllegalAccessException {
		final String expectedValue = getFieldValueAsString(field, entity);
		final String message = "Unable to find expected value " + expectedValue + " for field " + field.getName() + " in entity " + entity;
		assertTrue(message, unitAsString.contains(expectedValue));
	}

	private String getFieldValueAsString(final Field field, Object entity) throws IllegalAccessException {
		final Object value = field.get(entity);
		if (isArray(field)) {
			final String asString = asString(value);
			return asString.substring(1, asString.length() - 2);
		} else {
			return value.toString();
		}
	}
}