.. _hello_world:

==================
Hello BPjs World
==================

Let's start by writing the traditional `hello, world!`_ program. Instead of writing characters to the console, our program will generate two events, in the following order:

#. A "Hello" event

#. A "World" event

We assume you have downloaded and installed BPjs. This process is explained in :ref:`installing_bpjs`.

.. _hello, world!: https://en.wikipedia.org/wiki/%22Hello,_World!%22_program

The Sequential Version
----------------------

The "Hello, World" version below (:download:`source <code/hello-world-seq.js>`) contains a single b-thread, requesting the two events in sequence. Since it is the only b-thread in the program, these events are not blocked by anyone, and are the only available events. Thus, the arbiter select each one of them as they are requested.

.. literalinclude:: code/hello-world-seq.js
  :linenos:
  :language: javascript

This is not a very complicated example, but it does show a few basics worth mentioning. First, b-threads are normal javascript functions that take no parameters. They are added to the b-program using ``bp.registerBThread``. Note that the b-program is never explicitly started by the client code. Starting the b-program is done by BPjs for you.

Lines 2 and 3 contains a very simple ``bp.sync`` statement, requesting an event. The events are created using the event factory ``bp.Event(...)``. This code uses the simple version of ``bp.Event``, passing the event name only.
We'll see more of ``bp.XXX`` and ``bp.sync`` soon, but first let's run this program and see what happens.


Running this example
....................

Assuming ``bpjs.jar`` is the name of the BPjs jar, and that is it available at the system's PATH, running the program is done like so:

.. code:: bash
  :number-lines:

  $ java -jar bpjs.jar hello-world-seq.js
  #  [READ] /path/to/hello-world-seq.js
  -:BPjs Added autoadded-1
  #  [ OK ] hello-world-seq.js
  ---:BPjs Started
   --:BPjs Event [BEvent name:hello]
   --:BPjs Event [BEvent name:world]
  ---:BPjs No Event Selected
  ---:BPjs Ended

Lines 2 and 4 logs the loading and successful execution of the source file *hello-world-seq.js*. Line 3 records the addition of a b-thread (done in line 1 of the source). Lines 5-9 follow the execution of our little program. It starts, then the events are selected ("hello" and "world", as required). Then, no event is selected, so the program termintes.

Note the lifecycle of the program: files are first loaded and interpreted, and only then the b-program start all its b-threads. This will be important later, when we add b-threads dynamically. More on that later. Now, let's create a more complex version of "hello, world!".

Hello World with Wait
----------------------

Below is an updated version (:download:`source <code/hello-world-wait.js>`), containing two b-threads. One b-thread, called ``bt-hi``, requests the "hello" event and then terminates. The other b-thread, "bt-world", waits for the first event (line 2), and then requests the "world" event. The b-threads are named using the two-argument version of ``bp.registerBThread``, whose first parameter is the name of the b-thread, and second parameter is the b-thread itself.

The **trace**, or sequence of events generated by this program, is equivalent to that of `The Sequential Version`_. The program structure, on the other hand, is very different, as each requested event is done by a specific b-thread. However, ``bt-world`` is quite coupled to ``bt-hi``, as it waits for a specific event it emits. If the greeting would change to ``"shalom"``, ``"hol√†"``, or ``"goodbye"``, the program will break, unless ``bt-world`` is updated. This makes total sense in an eight-lines program, but in real world we would like to reduce coupling and increase cohesion. Let's see BP's take on this challenge.

.. literalinclude:: code/hello-world-wait.js
  :linenos:
  :language: javascript


Hello Block World
-------------------------
Here is what we'd ideally like to have (:download:`source <code/hello-world-decoupled.js>`):

.. literalinclude:: code/hello-world-decoupled.js
    :linenos:
    :language: javascript

Each b-thread is responsible for requesting its event only, so the code is very cohesive. But alas, the program may generate the events in the wrong order. This is because the event arbiter can choose which event to select first. In the example below, we have two runs generating different traces.

.. code:: bash
  :number-lines:

  $ java -jar bpjs.jar hello-world-decoupled.js
  #  [READ] /path/to/hello-world-decoupled.js
    -:BPjs Added bt-hi
    -:BPjs Added bt-world
  #  [ OK ] hello-world-decoupled.js
  ---:BPjs Started
   --:BPjs Event [BEvent name:hello]
   --:BPjs Event [BEvent name:world]
  ---:BPjs No Event Selected
  ---:BPjs Ended

  $ java -jar bpjs.jar hello-world-decoupled.js
  ...
  ---:BPjs Started
   --:BPjs Event [BEvent name:world]
   --:BPjs Event [BEvent name:hello]
  ...

To prevent the wrong order of events, we can add this additional b-thread (:download:`source <code/hello-world-decoupled-patch.js>`). It solves the "world before hello" issue by blocking the ``world`` event from being selecting, until the ``hello`` event is. This is done by passing ``bp.Event("world")`` as the ``block`` parameter of ``bp.sync``.

.. literalinclude:: code/hello-world-decoupled-patch.js
  :linenos:
  :language: javascript

We can now run both files in a single b-program, like so. Note that we are passing two files to the bpjs runtime:

.. code:: bash
  :number-lines:

  #  [READ] /Users/michael/Documents/PhD/Thesis/code/bThink-BGU/BPjs/docs/source/BPjsTutorial/code/hello-world-decoupled.js
  -:BPjs Added bt-hi
  -:BPjs Added bt-world
  #  [ OK ] hello-world-decoupled.js
  #  [READ] /Users/michael/Documents/PhD/Thesis/code/bThink-BGU/BPjs/docs/source/BPjsTutorial/code/hello-world-decoupled-patch.js
    -:BPjs Added hello world Patch
  #  [ OK ] hello-world-decoupled-patch.js
  ---:BPjs Started
   --:BPjs Event [BEvent name:hello]
   --:BPjs Event [BEvent name:world]
  ---:BPjs No Event Selected
  ---:BPjs Ended

The last example demonstrate how BP is suited for incremental, modular software development. We have changed the overall behavior of our b-program by adding new code, rather than by changing existing one. This change can be pulled out with no change to the rest of the program, in case we decide the order of the events does not matter.

Hello BPjs World
-----------------
Finally, let's change the program such that its trace read "hello BPjs world". Again, this can be done by adding the following b-thread (:download:`source <code/hello-world-bpjs.js>`).

.. literalinclude:: code/hello-world-bpjs.js
  :linenos:
  :language: javascript

Result:

.. code:: bash
  :number-lines:

  $ java -jar bpjs.jar hello-world-decoupled.js hello-world-decoupled-patch.js hello-world-bpjs.js
  #  [READ] /path/to/hello-world-decoupled.js
  -:BPjs Added bt-hi
  -:BPjs Added bt-world
  #  [ OK ] hello-world-decoupled.js
  #  [READ] /path/to/hello-world-decoupled-patch.js
  -:BPjs Added hello world Patch
  #  [ OK ] hello-world-decoupled-patch.js
  #  [READ] /path/to/hello-world-bpjs.js
  -:BPjs Added bpjs addition
  #  [ OK ] hello-world-bpjs.js
  ---:BPjs Started
  --:BPjs Event [BEvent name:hello]
  --:BPjs Event [BEvent name:BPjs]
  --:BPjs Event [BEvent name:world]
  ---:BPjs No Event Selected
  ---:BPjs Ended
